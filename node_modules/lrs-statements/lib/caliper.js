/**
 * Copyright Â©2016. The Regents of the University of California (Regents). All Rights Reserved.
 *
 * Permission to use, copy, modify, and distribute this software and its documentation
 * for educational, research, and not-for-profit purposes, without fee and without a
 * signed licensing agreement, is hereby granted, provided that the above copyright
 * notice, this paragraph and the following two paragraphs appear in all copies,
 * modifications, and distributions.
 *
 * Contact The Office of Technology Licensing, UC Berkeley, 2150 Shattuck Avenue,
 * Suite 510, Berkeley, CA 94720-1620, (510) 643-7201, otl@berkeley.edu,
 * http://ipira.berkeley.edu/industry-info for commercial licensing opportunities.
 *
 * IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT, SPECIAL,
 * INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING OUT OF
 * THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS BEEN ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
 * SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED HEREUNDER IS PROVIDED
 * "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
 * ENHANCEMENTS, OR MODIFICATIONS.
 */

var _ = require('lodash');
var joi = require('joi');
var uuid = require('uuid');
var config = require('config');

var DB = require('lrs-core/lib/db');
var log = require('lrs-core/lib/logger')('lrs-statements');
var caliperValidator = require('caliperjs/src/validator');

const CALIPER = 'CALIPER';

/**
 * Get a learning activity statement by its uuid
 *
 * @param  {String}           id                    The uuid by which to retrieve the learning activity statement
 * @param  {Function}         callback              Standard callback function
 * @param  {Object}           callback.err          An error that occurred, if any
 * @param  {Statement}        callback.statement    The requested learning activity statement
 */
var getStatement = module.exports.getStatement = function(id, callback) {
  // Parameter validation
  var validationSchema = joi.object().keys({
    'id': joi.string().required()
  });

  var validationResult = joi.validate({
    'id': id
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  DB.Statement.findById(id).complete(function(err, statement) {
    if (err) {
      log.error({'err': err, 'id': id}, 'An error occurred when getting a learning activity statement');
      return callback({'code': 500, 'msg': err.message});
    } else if (!statement) {
      return callback({'code': 404, 'msg': 'Could not find a learning activity statement'});
    }

    return callback(null, statement);
  });
};

/**
 * Validate and save a learning activity statement
 *
 * @param  {Object}           ctx                       Context containing write credentials
 * @param  {Object}           statement                 The learning activity statement to save
 * @param  {Function}         callback                  Standard callback function
 * @param  {Object}           callback.err              An error that occurred, if any
 */
var saveStatement = module.exports.saveStatement = function(ctx, statement, callback) {
  if (!ctx || !ctx.auth) {
    log.error({'err': err}, 'Prevented storing a learning activity without authentication');
    return callback({'code': 500, 'msg': 'Prevented storing a learning activity without authentication'});
  }

  getStatement(statement.uuid, function(err, retrievedStatement) {
    if (retrievedStatement) {
      log.error({'id': statement.uuid}, 'Attempted to save a learning activity statement that already exists');
      return callback({'code': 400, 'msg': 'Attempted to save a learning activity statement that already exists'});
    } else if (err && err.code !== 404) {
      log.error({'id': statement.uuid}, 'Unable to verify if learning activity statement already exists');
      return callback(err);
    }

    // Validate incoming Caliper statement
    validateStatement(statement, function(err, statement) {
      if (err) {
        log.error({'err': err}, 'The caliper statement had validation errors');
        return callback(err);
      }

      log.debug('The Caliper statement passed basic valid for now');

      var currentTimestamp = new Date().toISOString();

      // When no timestamp has been included, generate one
      statement.eventTime = statement.eventTime || currentTimestamp;

      // Get the user associated to this learning activity. If the user
      // doesn't exist yet, it will be created
      getOrCreateUser(ctx, statement, function(err, user) {
        if (err) {
          log.error({'err': err}, 'An error occured while getting the learning activity statement actor');
          return callback(err);
        }

        log.debug("User retrieved : " + JSON.stringify(user));

        // Store the learning activity statement in the DB
        var storedStatement = {
          'uuid': statement.uuid,
          'statement': statement,
          'verb': statement.type.toString(),
          'timestamp': statement.eventTime,
          'activity_type': statement.action.toString(),
          'voided': false,
          'tenant_id': ctx.auth.tenant_id,
          'user_id': user.id,
          'actor_type': statement.actor.type.toString(),
          'statement_type': CALIPER,
          'write_credential_id': ctx.auth.id
        };

        DB.Statement.create(storedStatement).complete(function(err, statement) {
          if (err) {
            log.error({'err': err}, 'Failed to store a new learning activity statement');
            return callback({'code': 500, 'msg': err.message});
          }

          log.info({'statement_id': statement.uuid}, 'Successfully stored learning activity statement');
          return callback(null, statement);
        });

      });
    });
  });
};

/**
 * Retrieve the user that corresponds to the actor on a learning activity statement.
 * If the user doesn't exist, it will be created.
 *
 * @param  {Object}           ctx                       Context containing write credentials
 * @param  {Object}           statement                 The learning activity statement to extract the actor from
 * @param  {Function}         callback                  Standard callback function
 * @param  {Object}           callback.err              An error that occurred, if any
 * @param  {Object}           callback.user             The requested user, or the generated user if the user didn't exist
 * @api private
 */

var getOrCreateUser = function(ctx, statement, callback) {
  // Extract the user's external id & name if available from the actor object
  // TODO : RegEx is tailored for UCB requirements. Revisit JSON parser to make it generic
  var name = null;
  var external_id = null;
  var userIdRegExp = new RegExp('[UID:0-9]+$');

  // Extract user information if actor type is Person or SoftwareApplication
  // TODO : Add support for other actor types like Organizations etc.
  if (statement.actor.hasOwnProperty('type') && statement.actor.hasOwnProperty('id') && statement.actor.type === 'Person') {
    log.info("External_ID for the user is : " + userIdRegExp.exec(statement.actor.id));
    external_id = userIdRegExp.exec(statement.actor.id).toString();
  } else if (statement.actor.type === 'SoftwareApplication') {
    if (statement.object.actor.hasOwnProperty('type') && statement.object.actor.hasOwnProperty('id') && statement.object.actor.type === 'Person') {
      log.info("External_ID for the user is : " + userIdRegExp.exec(statement.object.actor.id));
      external_id = userIdRegExp.exec(statement.object.actor.id).toString();
    }

  }

  if (!external_id) {
    log.info({'statement': statement}, 'Unable to extract user from statement');
    return callback({'code': 500, 'msg': 'Unable to extract user from statement'});
  }

  // Get the user from the DB or create it if it doesn't exist yet
  options = {
    'where': {
      'tenant_id': ctx.auth.tenant_id,
      'external_id': external_id
    },
    'defaults': {
      'tenant_id': ctx.auth.tenant_id,
      'external_id': external_id,
      'name': name
    }
  };

  DB.User.findOrCreate(options).complete(function(err, data) {
    if (err) {
      log.error({'err': err}, 'Failed to get or create a user');
      return callback({'code': 500, 'msg': err.message});
    }

    var user = data[0];
    return callback(null, user);
  });
};

/**
 * Check required Event properties against set of user-supplied values
 * @param  {Object}           statement                 The learning activity statement to be validated
 * @param  {Object}           callback.err              An error that occurred, if any
 * @param  {Object}           callback.statement        The validated statement with changes, if any
 */
var validateStatement = module.exports.validateStatement = function(statement, callback) {
  var validationError = '';
  Object.keys(statement).forEach(function(key) {
    switch (key) {
      case "@context":
      if (!caliperValidator.hasCaliperContext(statement)) {
        validationError = validationError + "\nRequired context not provided.";
      }
      break;
      case "type":
      if (!caliperValidator.hasType(statement)) {
        validationError = validationError + "\nRequired type not provided.";
      }
      break;
      case "uuid":
      if (!caliperValidator.hasUUID(statement)) {
        statement.uuid = uuid.v4();
      }
      break;
      case "actor":
      if (!caliperValidator.hasActor(statement)) {
        validationError = validationError + "\nRequired actor not provided.";
      }
      break;
      case "action":
      if (!caliperValidator.hasAction(statement)) {
        validationError = validationError + "\nRequired action not provided.";
      }
      break;
      case "object":
      if (!caliperValidator.hasObject(statement)) {
        validationError = validationError + "\nRequired object not provided.";
      }
      break;
      case "eventTime":
      if (!caliperValidator.hasEventTime(statement)) {
        validationError = validationError + "\nRequired ISO 8601 formatted eventTime not provided.";
      }
      break;
    }
  });

  if (validationError) {
    log.error("Validation errors found in Caliper statement");
    return callback({'code': 400, 'msg': validationError});
  } else {
    log.info("Caliper statement passed basic validation");
    return callback(null, statement);
  }

};
